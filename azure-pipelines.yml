# Node.js with Docker and Kubernetes CI/CD pipeline.t
# Build, test, and deploy a Node.js project with Docker and Kubernetes

trigger:
- main

# Define variables for different environments
variables:
- group: my-dockerhub-secrets
pool:
  name: garden-ubuntu

stages:
- stage: Build
  displayName: 'Build and Test'
  jobs:
  - job: BuildTest
    displayName: 'Build, Lint and Test'
    steps:
    - task: NodeTool@0
      inputs:
        versionSpec: '$(nodeVersion)'
      displayName: 'Install Node.js'

    # Install dependencies
    - script: |
        npm install
      displayName: 'Install Dependencies'
      
    # Run linting
    - script: |
        npm run lint
      displayName: 'Run Linting'
      
    # Run tests
    - script: |
        npm test
      displayName: 'Run Tests'
      
    # Build the application
    - script: |
        npm run build
      displayName: 'Build Application'
      
    # Install Docker if needed and check Docker info
    - script: |
        # Check if Docker is installed and running
        if ! command -v docker &> /dev/null; then
          echo "Docker is not installed. Installing Docker..."
          # Install Docker (this is a simplified example)
          sudo apt-get update
          sudo apt-get install -y apt-transport-https ca-certificates curl software-properties-common
          curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
          sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable"
          sudo apt-get update
          sudo apt-get install -y docker-ce docker-ce-cli containerd.io
          sudo systemctl start docker
          sudo systemctl enable docker
          sudo usermod -aG docker $USER
        fi
        
        # Display Docker version and info
        docker --version
        docker info
      displayName: 'Setup Docker'
      
    # Build Docker image
    - script: |
        # Verify Dockerfile exists
        ls -la docker/
        
        # Build the Docker image
        docker build -t $(dockerRegistry)/$(imageName):$(Build.BuildNumber) -t $(dockerRegistry)/$(imageName):latest -f docker/DOCKERFILE .
      displayName: 'Build Docker image'
    
    # Push Docker image
    - script: |
        # Skip if registry credentials are not set
        if [ -z "$(registryUser)" ] || [ -z "$(registryPassword)" ]; then
          echo "Registry credentials not set. Skipping push."
          exit 1
        fi
        
        # Login to registry
        echo "Logging in to Docker registry..."
        docker login $(dockerRegistry) -u $(registryUser) -p $(registryPassword)
        
        # Push images
        echo "Pushing images to registry..."
        docker push $(dockerRegistry)/$(imageName):$(Build.BuildNumber)
        docker push $(dockerRegistry)/$(imageName):latest
      displayName: 'Push Docker image'
      # Note: For security, set registryUser and registryPassword in pipeline variables

    # Debug: Show Docker-related environment variables (do not print secrets!)
    - script: |
        echo "registryUser: $registryUser"
        echo "dockerRegistry: $dockerRegistry"
        echo "imageName: $imageName"
      displayName: 'Show Docker env vars'

- stage: Deploy
  displayName: 'Deploy to Kubernetes'
  dependsOn: Build
  condition: succeeded()
  jobs:
  - job: DeployToK8s
    displayName: 'Deploy to Kubernetes'
    steps:
    # Install kubectl if needed
    - script: |
        if ! command -v kubectl &> /dev/null; then
          curl -LO "https://dl.k8s.io/release/stable.txt"
          curl -LO "https://dl.k8s.io/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/
        fi
      displayName: 'Install kubectl if needed'
        
    # Configure kubectl (use appropriate method for your setup)
    - script: |
        # Either use kubeconfig from variables or from a file
        echo "$(kubeconfig)" > $(Agent.TempDirectory)/config
        export KUBECONFIG=$(Agent.TempDirectory)/config
      displayName: 'Configure kubectl'
        
    # Update Kubernetes manifests with the new image tag
    - script: |
        # Update image tag in deployment.yaml
        sed -i 's|image: $(imageName):.*|image: $(dockerRegistry)/$(imageName):$(Build.BuildNumber)|g' kubernetes/deployment.yaml
      displayName: 'Update Kubernetes manifests'
            
    # Apply Kubernetes manifests
    - script: |
        # Apply deployment
        echo "Applying deployment manifest..."
        kubectl apply -f kubernetes/deployment.yaml -n $(k8sNamespace)
        
        # Check if service file exists and apply it
        if [ -f kubernetes/service.yaml ]; then
          echo "Applying service manifest..."
          kubectl apply -f kubernetes/service.yaml -n $(k8sNamespace)
        else
          echo "Warning: service.yaml not found!"
        fi
        
        # Apply Ingress manifest if it exists
        if [ -f kubernetes/ingress.yaml ]; then
          echo "Applying ingress manifest..."
          kubectl apply -f kubernetes/ingress.yaml -n $(k8sNamespace)
        else
          echo "Warning: ingress.yaml not found!"
        fi
            
        # Wait for deployment with shorter timeout and add diagnostics
        echo "Waiting for deployment to roll out (max 60 seconds)..."
        kubectl rollout status deployment/express-server-deployment -n $(k8sNamespace) --timeout=60s || {
          echo "Deployment did not complete in time. Checking pod status:"
          kubectl get pods -n $(k8sNamespace) -l app=express-server
          kubectl describe pods -n $(k8sNamespace) -l app=express-server
          
          # Check for registry issues
          echo "Checking for image pull status..."
          kubectl get events -n $(k8sNamespace) | grep -i "image"
          
          # Continue pipeline despite rollout timeout
          echo "Continuing pipeline despite rollout timeout..."
          exit 1
        }
      displayName: 'Deploy to Kubernetes'
